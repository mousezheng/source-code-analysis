JAVA 并发
===

## 什么是多线程

同一个应用程序里存在多个线程执行，即**多线程（Multithreading）**，一个线程就像独立的 CPU 来执行应用。因此，多线程应用就像是同一时刻有多个CPU执行不同代码的应用。

尽管一个线程不等于一个CPU，通常单个CPU通过共享时间的方式来执行多个线程，通过实现设置的时间（*时间片*）在每个线程间切换。应用程序可以让线程在不同CPU上执行。

## 为什么使用多线程

这有一些为什么在应用中使用多线程的原因，下面是一些常见的原因：
- 提高单个 CPU 利用率
- 提高多个 CPU 或者 多核 CPU 利用率
- 响应用户更快
- 响应用户更公平

### 提高单个 CPU 利用率

提高单个CPU利用率是最常见的原因之一，例如，如果一个线程等待网络响应资源，其他线程可以在同一时间使用 CPU 做其他事。此外，如果计算机有多个 CPU，或者 CPU 有多个核，此时多线程可以让应用程序利用额外的 CPU 核心。

### 提高多个 CPU 或者 多核 CPU 利用率

如果一个计算机有多个 CPU 或者 CPU 有多个执行核心，需要使用多线程让程序尽可能使用所有的 CPU 或者 CPU 核心。，正如上面所提及的，一个线程最多只能使用一个 CPU，即使不能充分利用单个 CPU

### 提高资源响应的用户体验

使用多线程的另一个原因是提供更好的用户体验。例如，如果点击一个 GUI 的按钮并且发送一个网络请求。如果你使用同一个的线程，即更新 GUI 又发送请求，线程就会因为等待网络请求响应，而把 GUI 卡死。更好的方案是，这个网络请求可以通过后台线程进行，这样 GUI 线程就不会被阻塞，从而可以相应其他请求。

### 响应用户更公平

第四个原因是在多个用户之间公平的共享计算机资源。例如，想象一个从客户端接收请求的服务并且仅仅有一个线程去处理这些请求。如果一个客户端发送一个请求需要很长时间执行，那么其他所有客户端请求将会被等待直到这个请求结束。每个请求都有他们自己的线程，然而没有一个任务可以彻底独占 CPU。

## 多线程 VS 多进程

以前的计算机只有单个 CPU ，并且同事只能执行单个应用程序。大多数小型计算机实际上是不足以同事为多个程序提供支持，因此没有尝试过。公平的说，许多的大型系统能够更久的同时执行多个程序，但个人计算机不能。

### 多进程

多进程的意思是计算机可以同事执行多个应用程序，尽管实际上并非同时，只不过是一个 CPU 在多个程序之间共享。操作系统会在正在运行的系统之间切换，使得每个程序至运行一段时间。

多进程给软件开发带来新的挑战。不能假设程序拥有 所有的 CPU 可用时间、所有内存或者其他计算机资源。一个好的程序应该释放所有长时间不使用的资源，以便于其他程序使用。

### 多线程

多线程的意思是指同一个程序允许有多个线程执行。一个线程可以被看做是一个 CPU 执行程序。当同一个程序有多个线程时，可以看做是有多个 CPU 执行相同的程序

## 多线程是有难度的

相同类的程序使用多线程可以极大的提高性能。然而比起多进程，多线程依然存在很多挑战。多个线程在同一个程序中执行，所以是同时读写相同的内存。在单个CPU机器上，由于两个线程不能真正的同时执行，一些错误不会发生。现代计算机，不仅有多核 CPU，甚至还有多线程 CPU。所以，多线程可以在多核或者 CPU 中分开并且同时执行。

如果 A 线程读取本地内存，B 线程在写同一个本地内存。先进行 A 线程的读？值是？通过 B 线程写？还是二者的混合？
如果是两个写线程 A，B同时操作相同的本地内存，写操作完成后最终的值是多少？先 A 线程写，再 B 线程写？还是而知的混合呢？

这些结果没有确定的预测。行为不是可预见的。结果是会时不时变化。因此，开发者知道如何处理使其能够可预测是十分重要的，学习如何控制线程，通过共享资源例如 内存、文件、数据库等等。这时 java 并发教程的一个话题。

## java 中的多线程和并发

java 是最早使得多线程对开发者简单可用的语言之一，java有多线程非常基础的功能。因此 java 开发者经常会面对上面的问题，这也是我写这个 java 并发笔记的原因。作为一个给自己的备注，并且有利于其他 java 开发小伙伴们。

这份笔记主要考虑 java 多线程，但是一些与发生在多线程中的问题，也会类似的发生在多进程和分布式系统中。因此这里使用 “并发” 而不是 “多线程”。

## 并发模块

首先假设 java 并发模块在相同程序并且通过共享对象的方式执行。这个类并发模块是典型的通过一个 “共享并发模块状态”。很多并发语言框架和工具都是基于这个并发模型设计的。

然而，自从 java 并发书籍被编写，甚至 java 5 并发工具被发布依赖，并发架构及设计发生了很多事。

共享状态并发模型引发了很多难以解决的并发问题。因此 一个。因此，被称为“无共享”或“分离状态”的替代并发模型已经普及。 在单独的状态并发模型中，线程不共享任何对象或数据。这避免了共享状态并发模型的许多并发访问问题。

出现了新的异步“独立状态”平台和工具包，例如Netty，Vert.x和Play / Akka和Qbit。新的非阻塞并发算法已经发布，并且新的非阻塞工具（例如LMax Disrupter）已添加到我们的工具箱中。Java 7中的 Fork and Join 框架和Java 8中的 collection stream API引入了新的函数式编程并行性。

通过所有这些新开发，现在是时候更新本 Java Concurrency 教程了。因此，本教程再次进行中。 只要有时间编写新教程，它们就会出版。