多线程最有价值的优势是一下几点：
- 提高 CPU 利用率
- 一些情况下程序设计更简单
- 更多响应的程序
- 设备和 CPU 资源在不同的任务之间能够更公平


## 提高 CPU 利用率

想想一个应用程序从本地文件系统读取并加工文件。假设从磁盘读取文件需要 5s，并且处理需要 2s，加工两个文件有会出现如下情况：
```txt
5s 读文件A
2s 处理文件A
5s 读文件B
2s 处理文件B
-----------------
共计 14s

```
当从磁盘读取文件时，CPU 大多数时间花费在等待磁盘读取数据上。这段时间 CPU 是十分空闲的。它可以做一些其他的事情。通过切换命令操作，使得 CPU 能够更好的被利用。例如这个执行方式：
```txt
5s 读文件A
5s 读文件B + 2s 处理文件A
2s 处理文件B
-----------------
共计 12s

```
CPU 等待第一个文件被读取，然后他开始读取第二个文件。当第二个文件被计算机 IO 组件读取时，CPU 处理第一个文件。当等待从磁盘读取文件时，CPU 是十分空闲的。

通常情况下，CPU 可以再等待 IO 时做一些其他的事。不仅仅是磁盘 IO，网络 IO、用户输入等。网络和磁盘 IO 通常会比 CPU 和 内存 IO 慢很多

## 一些情况下程序设计更简单

如果在单线程应用中，执行上述读取并处理文件时，就不得不跟踪每个文件的读取和处理状态。这时可以开启两个线程，每个线程仅仅只读取并处理单个文件。当等待磁盘读取文件时，这些线程将被阻塞。当等待时，线程可以使用 CPU 执行部分已读取文件的处理。最终结果是，磁盘整个事件都是忙的，读各种各样的文件到主存中，这个方案充分利用了磁盘和 CPU。并且 程序也很简单，通过每个线程仅跟踪单个文件。

## 更快响应的程序

从单线程应用到多线程应用的另一个使用的目标是使应用能够更快的响应。想象一个应用，监听一些端口输入请求。当一个请求被接收，她执行这个请求并且执行完才回来监听。参考代码如下：
```java
while(server is active){
    listen for request
    process request
}
```
如果请求需要很长时间执行，在此期间没有新的客户端发送请求到服务器。仅仅当服务器监听请求时才会被接收。

一个交替设计将监听线程传递给请求处理线程，然后处理完立即返回给监听线程。处理线程将执行请求并且发送回应到客户端，设计的参考代码如下：
```java
while(server is active){
    listen for request
    hand request to worker thread
}
```
这种方式服务器线程将在后台一直监听。因此更多的客户端可以发送请求到服务器。服务器有变得更加高效。

左面应用程序也类似，如果点击按钮，开始一个耗时的任务，并且执行线程任务是更新窗口和按钮等。当任务执行时，应用将会呈现无响应。任务可以被替换成工作线程来执行，当工作线程繁忙时，窗口线程是空闲的可以响应其他用户请求。当工作线程完成后，发信号给窗口线程。窗口线程可以将任务结果更新到应用窗口。程序基于工作线程方式设计可以更快的响应用户。

## 设备和 CPU 资源在不同的任务之间能够更公平

想象一个接收客户端请求的服务器，某个客户端发送一个请求，需要耗时 10s 处理，如果服务器处理所有的认为使用单线程，那么所有后面的请求将会被延迟处理，被迫等待直到前面全部请求被处理。

通过在多线程间划分 CPU 时间并切换线程执行，那么 CPU 可以共享执行时间，更加公平的在服务器的请求上。即使某个请求很慢，其他快的请求执行可以同时执行慢的请求。由于不能独占 CPU 资源，原本慢的任务会更慢。其他请求不得不等待更短的时间来处理，因为他们不必等待慢任务先执行完。如果只有满请求需要处理时，CPU 可以腾出空来值处理慢任务。