独立线程并发（Singlethreaded Concurrency）
=

单线程并发意思是看似同时执行多个任务，实际上在耽搁线程中，单线程并发表面上看起来有点矛盾。从前，多线程架构多个任务会分配在多个线程中并发执行，虽然单线程上执行多个任务看起来同时，但是系统和 CPU 在不同线程间切换任务是非常讲究的，在单线程并发教程中解释如何设计单线程并发设计，以及其具有什么优势。

注意： 这篇教程基于进程，后续会补充更多内容。

## 经典多线程架构（Classic Multi-threaded Architecture）

在经典的多线程设计中，分离任务到独立的线程中执行最具代表性，每个线程只执行同时一个任务。在一些设计中，每个任务创建一个新线程，任务完成线程就死亡。另一种设计是线程池是不销毁线程，同时从任务队列中取并且执行任务，执行完一个任务然后执行另一个。有关**线程池（thread pools）**的更多的内容在另一篇教程。

多线程设计的优势在于相对简单的分配工作在多个线程和多个CPU上处理，仅仅分配任务到一个线程，让系统和 CPU 安排执行。

但是，如果任务执行需要共享数据，在多线程设计会出现很多多线程问题，如资源竞争、死锁、starvation、slipped conditions, nested monitor lockout等。通常情况下，多线程共享同一数据或者数据结构，很大概率会发生并发问题，所以，需要非常认真设计。

一个景点的多线程架构有时会导致阻塞，当多个线程同时访问相同数据时。这取决于数据结构的实现方式，当其他线程访问数据结构时有些线程会被阻塞。

## 单线程/Same-threaded 架构（Single-threaded / Same-threaded Architecture）

景点多线程架构的替代方案是一个单线程或者 Same-threaded，程序中仅仅只有一个线程执行所有任务，这样就可以完全避开上文提到的并发问题。

可以扩展单线程架构使用多线程，如果每个线程的功能都是独立的或者隔离的单线程系统。在这个案例参考 Same-threaded 架构设计，所有数据需要执行任务仍然被隔离在单线程或者在同一个线程。

## 单线程架构挑战

如果只有单线程执行程序的所有任务，会造成以下问题：
- 阻塞 IO 在一个任务中执行会阻塞当前线程深知阻塞整个程序
- 长时间执行任务会拒绝执行其他任务，导致其他任务超时
- 单线程只能使用单个 CPU

可以解决这些问题，而不损失单线程并发架构本质的优势，并且不会使得整个设计变得太过复杂。

## 线程循环（Thread Loops）

大多数长时间运行的程序在各种各样的循环中，程序的主线程在等待外部程序输入的地方，处理输入并返回等待状态。
img

这种线程循环被用在服务程序（web 服务、服务等）和 GUI 程序中，有时候这种线程循环是不可见的，有时候不是。

### 暂停线程循环（Pausing the Thread Loop）

线程执行一个紧密循环（a tight loop）会浪费大量的 CPU 时间。线程运行没有做任何实质工作，这样也会浪费大量 CPU 时间。然而，如果线程执行循环空闲并且预估可以休息几毫秒，可以 “休眠”。这种方式可以减少 CPU 时间的浪费。

## 两类任务

线程循环有两种典型的任务类型在其生命周期中：

- 重复任务（Repeated tasks）
- 单次任务（One-off tasks）

有关这两个任务更多细节解释，在下面的章节：

### 重复任务（Repeated tasks）

重复任务是会再次发生的任务，重复执行并且重复整个线程执行的生命周期执行它，典型的，每次任务调用重复执行整个任务。

一个重复任务的例子，审核一组从网络连接输入的数据。如果任何被检测到的数据都会被处理，处理后重复任务直到某个特定调用。然而，需要再次重复检查入站数据，以使应用程序能够连续响应传入数据。
img

### 单次任务（One-off tasks）

一个单次任务指一个任务只需要被执行一次，单次任务可能很快执行，也可能需要很久。

一个短的任务指任务能够在一个执行阶段中充分完成，而又不会使执行该任务的线程因该线程承担的其他职责而延迟（其他任务必须执行）。

一个长的单次任务指，任务在一个阶段中需要很长时间才能完成，“花费很长时间”，我认为执行