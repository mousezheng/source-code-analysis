独立线程并发（Singlethreaded Concurrency）
=

单线程并发意思是看似同时执行多个任务，实际上在耽搁线程中，单线程并发表面上看起来有点矛盾。从前，多线程架构多个任务会分配在多个线程中并发执行，虽然单线程上执行多个任务看起来同时，但是系统和 CPU 在不同线程间切换任务是非常讲究的，在单线程并发教程中解释如何设计单线程并发设计，以及其具有什么优势。

注意： 这篇教程基于进程，后续会补充更多内容。

## 经典多线程架构（Classic Multi-threaded Architecture）

在经典的多线程设计中，分离任务到独立的线程中执行最具代表性，每个线程只执行同时一个任务。在一些设计中，每个任务创建一个新线程，任务完成线程就死亡。另一种设计是线程池是不销毁线程，同时从任务队列中取并且执行任务，执行完一个任务然后执行另一个。有关**线程池（thread pools）**的更多的内容在另一篇教程。

多线程设计的优势在于相对简单的分配工作在多个线程和多个CPU上处理，仅仅分配任务到一个线程，让系统和 CPU 安排执行。

但是，如果任务执行需要共享数据，在多线程设计会出现很多多线程问题，如资源竞争、死锁、starvation、slipped conditions, nested monitor lockout等。通常情况下，多线程共享同一数据或者数据结构，很大概率会发生并发问题，所以，需要非常认真设计。

一个景点的多线程架构有时会导致阻塞，当多个线程同时访问相同数据时。这取决于数据结构的实现方式，当其他线程访问数据结构时有些线程会被阻塞。

## 单线程/Same-threaded 架构（Single-threaded / Same-threaded Architecture）

景点多线程架构的替代方案是一个单线程或者 Same-threaded，程序中仅仅只有一个线程执行所有任务，这样就可以完全避开上文提到的并发问题。

可以扩展单线程架构使用多线程，如果每个线程的功能都是独立的或者隔离的单线程系统。在这个案例参考 Same-threaded 架构设计，所有数据需要执行任务仍然被隔离在单线程或者在同一个线程。

## 单线程架构挑战

如果只有单线程执行程序的所有任务，会造成以下问题：
- 阻塞 IO 在一个任务中执行会阻塞当前线程深知阻塞整个程序
- 长时间执行任务会拒绝执行其他任务，导致其他任务超时
- 单线程只能使用单个 CPU

可以解决这些问题，而不损失单线程并发架构本质的优势，并且不会使得整个设计变得太过复杂。

## 线程循环（Thread Loops）

大多数长时间运行的程序在各种各样的循环中，程序的主线程在等待外部程序输入的地方，处理输入并返回等待状态。
img

这种线程循环被用在服务程序（web 服务、服务等）和 GUI 程序中，有时候这种线程循环是不可见的，有时候不是。

### 暂停线程循环（Pausing the Thread Loop）

线程执行一个紧密循环（a tight loop）会浪费大量的 CPU 时间。线程运行没有做任何实质工作，这样也会浪费大量 CPU 时间。然而，如果线程执行循环空闲并且预估可以休息几毫秒，可以 “休眠”。这种方式可以减少 CPU 时间的浪费。

## 两类任务

线程循环有两种典型的任务类型在其生命周期中：

- 重复任务（Repeated tasks）
- 单次任务（One-off tasks）

有关这两个任务更多细节解释，在下面的章节：

### 重复任务（Repeated tasks）

重复任务是会再次发生的任务，重复执行并且重复整个线程执行的生命周期执行它，典型的，每次任务调用重复执行整个任务。

一个重复任务的例子，审核一组从网络连接输入的数据。如果任何被检测到的数据都会被处理，处理后重复任务直到某个特定调用。然而，需要再次重复检查入站数据，以使应用程序能够连续响应传入数据。
img

### 单次任务（One-off tasks）

一个单次任务指一个任务只需要被执行一次，单次任务可能很快执行，也可能需要很久。

一个短的任务指任务能够在一个执行阶段中充分完成，而又不会使执行该任务的线程因该线程承担的其他职责而延迟（其他任务必须执行）。

一个长的单次任务指，任务在一个阶段中需要很长时间才能完成。“花费很长时间”的意思是执行任务中所有工作花费很长线程时间，所以 其他重复的任务单次任务将被延迟很多，以至于损害整个应用程序的响应能力。

在单个长期任务中尽量避免执行时间过长的线程，将完成任务所需的全部工作分解为可执行的单个小块，每块必须足够小，以免线程执行过多，造成其他任务的延迟。

长任务持续跟踪内部块的执行，线程执行长任务将多次调用他自身执行方法，直到所有任务块被执行。

在一个特别的长任务调用执行法法中，线程必须调用其他长任务的执行方法、其他重复任务或者线程有什么任务。

一个单次任务处理一个目录下的 n 个文件， 执行所有文件在耽搁执行阶段，执行 n 个文件可以分成多个小块，每块都在耽搁执行阶段中执行。例如 每个执行阶段处理一个文件。在一个线程循环中处理 n 个文件任务，单次任务通常发现并执行通过重复任务，如下图所示
img

### 单线程任务切换（Singlethreaded Task Switching）

多任务看似同时进行，实际上是多任务中线程切换运行，这个可以称作**任务切换**。

任务如何切换取决于任务的类型，线程是否是在重复任务或者单次任务间切换，虽然原理上类似，下文对这两种情况进行详细说明：

#### 切换任务-重复任务（Task Switching Between Repeated Tasks）

重复任务通常有单个方法，通过同一个线程反复调用。一个重复任务是在生命周期中一直重复，所以，从来不会“完成”，重复任务做他需要做的是，然后执行方法退出，然后将控制权返还给调用线程。

单个线程可以切换多个重复任务，通过以循环的方式调用他们的执行方法，第一个重复任务 A 获得一个执行机会，然后 B、然后 C、然后 A重复...

案例中一个重复任务任何开始的工作都没有整个完成，它内部会记录运行情况，并在下一个重复任务被调用的时机。
img

#### 任务切换-单次任务（Task Switching Between One-off Tasks）

单次任务与重复任务的不同是，单次任务可能在某个时间点执行完成，意思是，一些单次任务需要被益处从任务池中。

其他的，单次任务的任务切换类似多次任务的切换，执行线程调用一个特定的单次任务执行方法，任务在一个短的时间周期运行，然后记录内部状态，并且执行退出方法，让出控制权给调用线程。调用线程可以立刻循环的调用任务池中的单次任务。
img

### 重复任务和单次任务组合（Combining Repeated Tasks and One-off Tasks）

在实践中，一个应用由多个重复任务线程循环组成，并且重复任务需要执行单次任务作为他重复行为的一部分，设计图如下：。设计图仅描述单个重复任务，任务的数量取决于具体的应用。

## 平衡任务 （Task Balancing）

当一个单线程在多个任务间切换，是否是重复任务或单次任务，当务之急是在每次调用任务时不要占用太多线程的执行时间。换而言之，保证每个任务公平执行，是每个任务的职责。

任务执行多长时间应取决于系统设计者，单次任务会非常复杂。一些任务本身是很快的执行，其他任务需要更长的时间执行。对于运行时间较长的任务，由任务实现着来估计如何将工作分解成足够小的分区，以便能在不延迟其他任务过多的情况下执行每个分区。

一个有趣的事是，如果线程循环调用每个单次任务，然后多个单次任务执行者容器。每个线程获得的执行时间更少，因为在下一个任务获得执行时间之前，它花费的时间更长。

### 优先执行

任务分为优先任务和非优先任务是很有必要的，例如任务执行者可以保证任务在不同的列表中，或者，在优先级高的列表中执行 2 个时间片，在优先级低的列表中执行 1 个时间片。

恰好 一个优先任务执行者是否重要取决于具体的需要，还有多个优先层如，高/低， 低/中/高

### 任务暂存区

如果单次任务是等待一些异步操作完成，例如等待远端服务响应。单次任务不会继续执行，直到异步操作等待完成，在这个案例中感受不到任务不能运行，并被反复调用直到实现并且返回控制权到调用线程。

这种情况，任务可以被叫做**暂存（park）**，并在任务执行者内，他不是长时间的调用。当异步操作完成单次任务编程非暂存任务 ，然后插入到就绪任务中等待调用执行。当然，非暂存任务，系统其他的部分必须发现 异步操作完成，并且任务不暂存异步操作。

## 单线程并发扩展

明显的，如果应用中只有单个线程，不能利用多 CPU，可以开始多个线程利用多 CPU。典型的，一个线程一个CPU 取决于线程需要执行的任务类型。如果有需要执行阻塞IO工作任务，例如从系统或网络读文件。然后每个 CPU 需要超过一个线程，每个线程阻塞，并且什么都不做，等待阻塞IO操作完成。

img
当一个线程架构扩展成多个单线程子系统时，技术上不再是单线程。然而，一个单线程系统，每个单线程自统统被典型的设计成上图那样。多线程单线程系统称为 same-threaded 系统，然而 不确定这是不是最准确的术语。我们可能需要重新审视这些不同的设计，并在将来为它们提供更具描述性的术语。
